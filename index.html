<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Power Automate Flow Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .main-content {
            padding: 30px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ffffff, #f8fafc);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);
            border-left: 5px solid;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }

        .stat-card.success { border-left-color: #10b981; }
        .stat-card.warning { border-left-color: #f59e0b; }
        .stat-card.error { border-left-color: #ef4444; }
        .stat-card.info { border-left-color: #3b82f6; }

        .stat-number {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-card.success .stat-number { color: #10b981; }
        .stat-card.warning .stat-number { color: #f59e0b; }
        .stat-card.error .stat-number { color: #ef4444; }
        .stat-card.info .stat-number { color: #3b82f6; }

        .stat-label {
            color: #6b7280;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 144, 226, 0.4);
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #e5e7eb;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .search-box {
            flex: 1;
            min-width: 200px;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .search-box:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .flows-section {
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .section-header {
            background: #f8fafc;
            padding: 20px 25px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1f2937;
        }

        .last-updated {
            font-size: 0.85rem;
            color: #6b7280;
        }

        .flows-list {
            max-height: 600px;
            overflow-y: auto;
        }

        .flow-item {
            padding: 20px 25px;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.3s ease;
        }

        .flow-item:hover {
            background: #fafbfc;
        }

        .flow-item:last-child {
            border-bottom: none;
        }

        .flow-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .flow-name {
            font-weight: 600;
            font-size: 1.1rem;
            color: #1f2937;
            margin-bottom: 5px;
        }

        .flow-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .status-enabled { background: #d1fae5; color: #065f46; }
        .status-suspended { background: #fef3c7; color: #92400e; }
        .status-stopped { background: #fee2e2; color: #991b1b; }
        
        .run-status-succeeded { background: #d1fae5; color: #065f46; }
        .run-status-failed { background: #fee2e2; color: #991b1b; }
        .run-status-running { background: #dbeafe; color: #1e40af; }
        .run-status-cancelled { background: #f3f4f6; color: #4b5563; }

        .flow-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            color: #6b7280;
            font-size: 0.85rem;
        }

        .flow-metric {
            display: flex;
            flex-direction: column;
        }

        .metric-label {
            font-weight: 500;
            margin-bottom: 2px;
        }

        .metric-value {
            font-size: 0.9rem;
            color: #374151;
        }

        .error-message {
            color: #ef4444;
            font-size: 0.8rem;
            margin-top: 5px;
            font-style: italic;
        }

        .alert-banner {
            padding: 15px 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            display: none;
            border-left: 5px solid;
        }

        .alert-banner.show {
            display: block;
            animation: slideDown 0.3s ease;
        }

        .alert-banner.success {
            background: linear-gradient(135deg, #d1fae5, #a7f3d0);
            border-left-color: #10b981;
            color: #065f46;
        }

        .alert-banner.error {
            background: linear-gradient(135deg, #fee2e2, #fecaca);
            border-left-color: #ef4444;
            color: #991b1b;
        }

        .alert-banner.warning {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border-left-color: #f59e0b;
            color: #92400e;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }

        .spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #4a90e2;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .config-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
        }

        .config-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-label {
            font-weight: 500;
            color: #374151;
            margin-bottom: 5px;
        }

        .form-input {
            padding: 10px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            transition: border-color 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            margin-left: auto;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
        }

        .status-indicator.connected {
            background: #10b981;
        }

        .troubleshoot-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .troubleshoot-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .troubleshoot-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .troubleshoot-modal.show .troubleshoot-content {
            transform: scale(1);
        }

        .troubleshoot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e5e7eb;
        }

        .troubleshoot-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 5px;
        }

        .close-btn:hover {
            color: #374151;
        }

        .test-section {
            margin-bottom: 25px;
            padding: 20px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            background: #f9fafb;
        }

        .test-section.running {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .test-section.success {
            border-color: #10b981;
            background: #ecfdf5;
        }

        .test-section.error {
            border-color: #ef4444;
            background: #fef2f2;
        }

        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .test-name {
            font-weight: 600;
            font-size: 1.1rem;
            color: #1f2937;
        }

        .test-status {
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .test-status.pending { background: #f3f4f6; color: #6b7280; }
        .test-status.running { background: #dbeafe; color: #1e40af; }
        .test-status.success { background: #d1fae5; color: #065f46; }
        .test-status.error { background: #fee2e2; color: #991b1b; }

        .test-details {
            font-size: 0.9rem;
            color: #6b7280;
            margin-bottom: 15px;
        }

        .test-result {
            font-family: 'Monaco', 'Menlo', monospace;
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            white-space: pre-wrap;
            font-size: 0.85rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .test-result.error {
            color: #ef4444;
            border-color: #ef4444;
        }

        .test-result.success {
            color: #059669;
            border-color: #10b981;
        }

        .run-all-tests-btn {
            width: 100%;
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #357abd);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Power Automate Monitor</h1>
            <p>Real-time monitoring and alerting for your Microsoft Power Automate flows</p>
        </div>

        <div class="main-content">
            <div class="config-panel">
                <h3 style="margin-bottom: 20px; color: #1f2937;">Configuration</h3>
                <div class="config-row">
                    <div class="form-group">
                        <label class="form-label">Environment URL</label>
                        <input type="text" class="form-input" id="environmentUrl" placeholder="https://yourtenant.crm.dynamics.com/">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Refresh Interval (seconds)</label>
                        <input type="number" class="form-input" id="refreshInterval" value="30" min="10" max="300">
                    </div>
                </div>
                <div class="config-row">
                    <div class="form-group">
                        <label class="form-label">Client ID</label>
                        <input type="text" class="form-input" id="clientId" placeholder="Your Azure AD App Client ID">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Tenant ID</label>
                        <input type="text" class="form-input" id="tenantId" placeholder="Your Azure AD Tenant ID">
                    </div>
                </div>
            </div>

            <div class="alert-banner" id="alertBanner">
                <strong id="alertIcon">‚ÑπÔ∏è</strong> <span id="alertMessage"></span>
            </div>

            <div class="stats-grid">
                <div class="stat-card success">
                    <div class="stat-number" id="enabledCount">-</div>
                    <div class="stat-label">Enabled Flows</div>
                </div>
                <div class="stat-card error">
                    <div class="stat-number" id="suspendedCount">-</div>
                    <div class="stat-label">Suspended Flows</div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-number" id="failedRunsCount">-</div>
                    <div class="stat-label">Recent Failures</div>
                </div>
                <div class="stat-card info">
                    <div class="stat-number" id="totalFlows">-</div>
                    <div class="stat-label">Total Flows</div>
                </div>
            </div>

            <div class="controls">
                <button class="btn btn-primary" id="connectBtn">üîå Connect to Power Platform</button>
                <button class="btn btn-secondary" id="refreshBtn" disabled>üîÑ Refresh Data</button>
                <button class="btn btn-secondary" id="exportBtn" disabled>üìä Export Report</button>
                <button class="btn btn-secondary" id="troubleshootBtn">üîß Troubleshoot Connection</button>
                <input type="text" class="search-box" id="searchBox" placeholder="üîç Search flows by name..." disabled>
                <div class="connection-status">
                    <div class="status-indicator" id="statusIndicator"></div>
                    <span id="connectionStatus">Disconnected</span>
                </div>
            </div>

            <div class="flows-section">
                <div class="section-header">
                    <div class="section-title">Flow Status Monitor</div>
                    <div class="last-updated" id="lastUpdated">Never updated</div>
                </div>
                <div class="flows-list" id="flowsList">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Click "Connect to Power Platform" to start monitoring your flows</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Troubleshooting Modal -->
    <div class="troubleshoot-modal" id="troubleshootModal">
        <div class="troubleshoot-content">
            <div class="troubleshoot-header">
                <h2 class="troubleshoot-title">üîß Connection Troubleshooting</h2>
                <button class="close-btn" id="closeTroubleshootBtn">&times;</button>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <button class="btn btn-primary run-all-tests-btn" id="runAllTestsBtn">üß™ Run All Tests</button>

            <div class="test-section" id="configTest">
                <div class="test-header">
                    <div class="test-name">1. Configuration Validation</div>
                    <div class="test-status pending" id="configTestStatus">Pending</div>
                </div>
                <div class="test-details">Validates that all required configuration parameters are properly formatted</div>
                <div class="test-result" id="configTestResult" style="display: none;"></div>
            </div>

            <div class="test-section" id="urlTest">
                <div class="test-header">
                    <div class="test-name">2. Environment URL Connectivity</div>
                    <div class="test-status pending" id="urlTestStatus">Pending</div>
                </div>
                <div class="test-details">Tests if the Power Platform environment URL is reachable</div>
                <div class="test-result" id="urlTestResult" style="display: none;"></div>
            </div>

            <div class="test-section" id="authTest">
                <div class="test-header">
                    <div class="test-name">3. Authentication Test</div>
                    <div class="test-status pending" id="authTestStatus">Pending</div>
                </div>
                <div class="test-details">Verifies Azure AD authentication configuration and token acquisition</div>
                <div class="test-result" id="authTestResult" style="display: none;"></div>
            </div>

            <div class="test-section" id="apiTest">
                <div class="test-header">
                    <div class="test-name">4. API Endpoint Test</div>
                    <div class="test-status pending" id="apiTestStatus">Pending</div>
                </div>
                <div class="test-details">Tests connectivity to Power Automate API endpoints</div>
                <div class="test-result" id="apiTestResult" style="display: none;"></div>
            </div>

            <div class="test-section" id="permissionTest">
                <div class="test-header">
                    <div class="test-name">5. Permissions Check</div>
                    <div class="test-status pending" id="permissionTestStatus">Pending</div>
                </div>
                <div class="test-details">Verifies that the application has necessary permissions to read flows</div>
                <div class="test-result" id="permissionTestResult" style="display: none;"></div>
            </div>

            <div class="test-section" id="networkTest">
                <div class="test-header">
                    <div class="test-name">6. Network & CORS Test</div>
                    <div class="test-status pending" id="networkTestStatus">Pending</div>
                </div>
                <div class="test-details">Checks for network connectivity issues and CORS policy problems</div>
                <div class="test-result" id="networkTestResult" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        class PowerAutomateMonitor {
            constructor() {
                this.flows = [];
                this.filteredFlows = [];
                this.isConnected = false;
                this.refreshTimer = null;
                this.accessToken = null;
                this.environment = null;
                this.config = {
                    environmentUrl: '',
                    clientId: '',
                    tenantId: '',
                    refreshInterval: 30
                };
                
                this.initializeEventListeners();
                this.loadConfiguration();
            }

            initializeEventListeners() {
                const elements = {
                    connectBtn: document.getElementById('connectBtn'),
                    refreshBtn: document.getElementById('refreshBtn'),
                    exportBtn: document.getElementById('exportBtn'),
                    troubleshootBtn: document.getElementById('troubleshootBtn'),
                    searchBox: document.getElementById('searchBox'),
                    environmentUrl: document.getElementById('environmentUrl'),
                    clientId: document.getElementById('clientId'),
                    tenantId: document.getElementById('tenantId'),
                    refreshInterval: document.getElementById('refreshInterval'),
                    runAllTestsBtn: document.getElementById('runAllTestsBtn'),
                    closeTroubleshootBtn: document.getElementById('closeTroubleshootBtn')
                };

                elements.connectBtn.addEventListener('click', () => this.handleConnect());
                elements.refreshBtn.addEventListener('click', () => this.refreshData());
                elements.exportBtn.addEventListener('click', () => this.exportReport());
                elements.troubleshootBtn.addEventListener('click', () => this.openTroubleshootModal());
                elements.searchBox.addEventListener('input', (e) => this.filterFlows(e.target.value));
                elements.runAllTestsBtn.addEventListener('click', () => this.runAllTests());
                elements.closeTroubleshootBtn.addEventListener('click', () => this.closeTroubleshootModal());
                
                // Close modal when clicking outside
                document.getElementById('troubleshootModal').addEventListener('click', (e) => {
                    if (e.target.id === 'troubleshootModal') {
                        this.closeTroubleshootModal();
                    }
                });
                
                // Configuration change listeners
                Object.keys(this.config).forEach(key => {
                    const element = elements[key];
                    if (element) {
                        element.addEventListener('change', () => this.updateConfiguration());
                    }
                });
            }

            loadConfiguration() {
                // Load from URL parameters or local configuration
                const urlParams = new URLSearchParams(window.location.search);
                
                Object.keys(this.config).forEach(key => {
                    const urlValue = urlParams.get(key);
                    const element = document.getElementById(key);
                    
                    if (urlValue && element) {
                        element.value = urlValue;
                        this.config[key] = urlValue;
                    } else if (element) {
                        this.config[key] = element.value;
                    }
                });
            }

            updateConfiguration() {
                this.config = {
                    environmentUrl: document.getElementById('environmentUrl').value.trim(),
                    clientId: document.getElementById('clientId').value.trim(),
                    tenantId: document.getElementById('tenantId').value.trim(),
                    refreshInterval: parseInt(document.getElementById('refreshInterval').value) || 30
                };

                // Restart auto-refresh with new interval if connected
                if (this.isConnected) {
                    this.startAutoRefresh();
                }
            }

            validateConfiguration() {
                const { environmentUrl, clientId, tenantId } = this.config;
                
                if (!environmentUrl || !clientId || !tenantId) {
                    throw new Error('Please fill in all required configuration fields');
                }

                try {
                    new URL(environmentUrl);
                } catch {
                    throw new Error('Invalid environment URL format');
                }

                // Basic GUID format validation for Azure AD IDs
                const guidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                if (!guidPattern.test(clientId) || !guidPattern.test(tenantId)) {
                    throw new Error('Client ID and Tenant ID must be valid GUIDs');
                }
            }

            async handleConnect() {
                try {
                    this.validateConfiguration();
                    await this.authenticate();
                    await this.fetchFlows();
                    this.setConnectedState(true);
                    this.showAlert('Successfully connected to Power Platform! Monitoring active flows.', 'success');
                    this.startAutoRefresh();
                } catch (error) {
                    this.setConnectedState(false);
                    this.showAlert(`Connection failed: ${error.message}. Click "Troubleshoot Connection" for detailed diagnostics.`, 'error');
                    console.error('Connection error:', error);
                }
            }

            // Troubleshooting Modal Methods
            openTroubleshootModal() {
                document.getElementById('troubleshootModal').classList.add('show');
                this.resetTestResults();
            }

            closeTroubleshootModal() {
                document.getElementById('troubleshootModal').classList.remove('show');
            }

            resetTestResults() {
                const testIds = ['configTest', 'urlTest', 'authTest', 'apiTest', 'permissionTest', 'networkTest'];
                
                testIds.forEach(testId => {
                    const section = document.getElementById(testId);
                    const status = document.getElementById(testId + 'Status');
                    const result = document.getElementById(testId + 'Result');
                    
                    section.className = 'test-section';
                    status.className = 'test-status pending';
                    status.textContent = 'Pending';
                    result.style.display = 'none';
                    result.textContent = '';
                });

                document.getElementById('progressFill').style.width = '0%';
            }

            async runAllTests() {
                const runBtn = document.getElementById('runAllTestsBtn');
                const originalText = runBtn.textContent;
                
                runBtn.disabled = true;
                runBtn.textContent = 'üß™ Running Tests...';
                
                try {
                    const tests = [
                        { id: 'configTest', name: 'Configuration Validation', fn: () => this.testConfiguration() },
                        { id: 'urlTest', name: 'Environment URL Connectivity', fn: () => this.testUrlConnectivity() },
                        { id: 'authTest', name: 'Authentication Test', fn: () => this.testAuthentication() },
                        { id: 'apiTest', name: 'API Endpoint Test', fn: () => this.testApiEndpoints() },
                        { id: 'permissionTest', name: 'Permissions Check', fn: () => this.testPermissions() },
                        { id: 'networkTest', name: 'Network & CORS Test', fn: () => this.testNetworkAndCors() }
                    ];

                    for (let i = 0; i < tests.length; i++) {
                        const test = tests[i];
                        const progress = ((i + 1) / tests.length) * 100;
                        
                        await this.runSingleTest(test.id, test.name, test.fn);
                        document.getElementById('progressFill').style.width = `${progress}%`;
                        
                        // Small delay between tests for better UX
                        await this.delay(500);
                    }
                    
                } finally {
                    runBtn.disabled = false;
                    runBtn.textContent = originalText;
                }
            }

            async runSingleTest(testId, testName, testFn) {
                const section = document.getElementById(testId);
                const status = document.getElementById(testId + 'Status');
                const result = document.getElementById(testId + 'Result');
                
                // Set running state
                section.className = 'test-section running';
                status.className = 'test-status running';
                status.textContent = 'Running...';
                result.style.display = 'block';
                result.className = 'test-result';
                result.textContent = 'Running diagnostic test...';
                
                try {
                    const testResult = await testFn();
                    
                    // Set success state
                    section.className = 'test-section success';
                    status.className = 'test-status success';
                    status.textContent = 'Passed';
                    result.className = 'test-result success';
                    result.textContent = testResult.message || 'Test completed successfully';
                    
                } catch (error) {
                    // Set error state
                    section.className = 'test-section error';
                    status.className = 'test-status error';
                    status.textContent = 'Failed';
                    result.className = 'test-result error';
                    result.textContent = `‚ùå ${error.message}\n\n${error.details || 'No additional details available.'}`;
                }
            }

            async testConfiguration() {
                const { environmentUrl, clientId, tenantId, refreshInterval } = this.config;
                const results = [];
                
                // Test environment URL
                if (!environmentUrl) {
                    throw new Error('Environment URL is required');
                } else {
                    try {
                        const url = new URL(environmentUrl);
                        if (!url.hostname.includes('crm') && !url.hostname.includes('dynamics')) {
                            results.push('‚ö†Ô∏è URL doesn\'t appear to be a Dynamics 365/Power Platform environment');
                        } else {
                            results.push('‚úÖ Environment URL format is valid');
                        }
                    } catch {
                        throw new Error('Environment URL is not a valid URL format');
                    }
                }

                // Test Client ID
                const guidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                if (!clientId) {
                    throw new Error('Client ID is required');
                } else if (!guidPattern.test(clientId)) {
                    throw new Error('Client ID must be a valid GUID format');
                } else {
                    results.push('‚úÖ Client ID format is valid');
                }

                // Test Tenant ID
                if (!tenantId) {
                    throw new Error('Tenant ID is required');
                } else if (!guidPattern.test(tenantId)) {
                    throw new Error('Tenant ID must be a valid GUID format');
                } else {
                    results.push('‚úÖ Tenant ID format is valid');
                }

                // Test refresh interval
                if (refreshInterval < 10 || refreshInterval > 300) {
                    results.push('‚ö†Ô∏è Refresh interval should be between 10-300 seconds for optimal performance');
                } else {
                    results.push('‚úÖ Refresh interval is within recommended range');
                }

                return { message: results.join('\n') };
            }

            async testUrlConnectivity() {
                const { environmentUrl } = this.config;
                
                try {
                    // Test basic connectivity
                    const testUrl = new URL('/api/data/v9.0/$metadata', environmentUrl).href;
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                    
                    const response = await fetch(testUrl, {
                        method: 'HEAD',
                        mode: 'no-cors', // This will always succeed but we can catch network errors
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);
                    
                    return {
                        message: `‚úÖ Environment URL is reachable\nüìç Testing endpoint: ${testUrl}\nüåê Connection successful (network layer)`
                    };
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Connection timeout - Environment URL is not reachable within 10 seconds');
                    }
                    
                    const details = `üîç Tested URL: ${environmentUrl}\nüìã Error Details: ${error.message}\n\nüí° Common causes:\n- Environment URL is incorrect\n- Environment is not accessible from this network\n- DNS resolution issues\n- Firewall blocking the connection`;
                    
                    const err = new Error('Unable to connect to the Power Platform environment');
                    err.details = details;
                    throw err;
                }
            }

            async testAuthentication() {
                const { tenantId, clientId } = this.config;
                
                try {
                    // Test Azure AD discovery endpoint
                    const discoveryUrl = `https://login.microsoftonline.com/${tenantId}/v2.0/.well-known/openid_configuration`;
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);
                    
                    const response = await fetch(discoveryUrl, {
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`Azure AD tenant validation failed: ${response.status}`);
                    }

                    const config = await response.json();
                    
                    const results = [
                        '‚úÖ Azure AD tenant is valid and accessible',
                        `üè¢ Tenant: ${tenantId}`,
                        `üîë Authorization endpoint: ${config.authorization_endpoint}`,
                        `üé´ Token endpoint: ${config.token_endpoint}`,
                        '\nüìù Note: Actual token acquisition requires user interaction and cannot be fully tested here.'
                    ];

                    return { message: results.join('\n') };
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Authentication service timeout');
                    }

                    const details = `üîç Tested tenant: ${tenantId}\nüìã Error: ${error.message}\n\nüí° Common causes:\n- Tenant ID is incorrect\n- Tenant doesn't exist or is not accessible\n- Network issues with Azure AD endpoints`;
                    
                    const err = new Error('Azure AD authentication test failed');
                    err.details = details;
                    throw err;
                }
            }

            async testApiEndpoints() {
                const { environmentUrl } = this.config;
                
                try {
                    const apiEndpoints = [
                        '/api/data/v9.0/$metadata',
                        '/api/data/v9.0/workflows',
                        '/api/data/v9.0/workflowlogs'
                    ];

                    const results = ['üîó Testing Power Automate API endpoints:'];
                    
                    for (const endpoint of apiEndpoints) {
                        try {
                            const testUrl = new URL(endpoint, environmentUrl).href;
                            
                            // Note: We can't actually test auth-required endpoints without a token
                            // But we can test if the endpoints are structured correctly
                            results.push(`‚úÖ ${endpoint} - Endpoint structure valid`);
                            
                        } catch (error) {
                            results.push(`‚ùå ${endpoint} - Invalid endpoint structure`);
                        }
                    }

                    results.push('\nüìù Note: Full API testing requires valid authentication token.');
                    results.push('üí° These endpoints will be used for flow data retrieval.');

                    return { message: results.join('\n') };
                    
                } catch (error) {
                    const details = `üìã Error: ${error.message}\n\nüí° This indicates issues with the environment URL format or API endpoint construction.`;
                    
                    const err = new Error('API endpoint configuration test failed');
                    err.details = details;
                    throw err;
                }
            }

            async testPermissions() {
                const { clientId } = this.config;
                
                // Simulate permission check
                await this.delay(1000);
                
                const requiredPermissions = [
                    'https://service.powerapps.com/Workflows.Read.All',
                    'https://service.powerapps.com/Workflows.ReadWrite.All'
                ];

                const results = [
                    `üîê Required API Permissions for Client ID: ${clientId}`,
                    '',
                    'üìã Required permissions for full functionality:',
                    ...requiredPermissions.map(perm => `   ‚Ä¢ ${perm}`),
                    '',
                    '‚ö†Ô∏è Note: Permission validation requires admin consent and cannot be fully tested here.',
                    '',
                    'üí° To verify permissions in Azure Portal:',
                    '   1. Go to Azure AD > App registrations',
                    '   2. Find your application by Client ID',
                    '   3. Check "API permissions" section',
                    '   4. Ensure admin consent is granted'
                ];

                return { message: results.join('\n') };
            }

            async testNetworkAndCors() {
                try {
                    // Test general internet connectivity
                    const testUrls = [
                        'https://login.microsoftonline.com',
                        'https://graph.microsoft.com',
                        'https://service.powerapps.com'
                    ];

                    const results = ['üåê Testing network connectivity to Microsoft services:'];
                    
                    for (const url of testUrls) {
                        try {
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 3000);
                            
                            await fetch(url + '/favicon.ico', {
                                method: 'HEAD',
                                mode: 'no-cors',
                                signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            results.push(`‚úÖ ${url} - Reachable`);
                            
                        } catch (error) {
                            if (error.name === 'AbortError') {
                                results.push(`‚ö†Ô∏è ${url} - Timeout (may indicate network issues)`);
                            } else {
                                results.push(`‚ùå ${url} - Connection failed`);
                            }
                        }
                    }

                    results.push('');
                    results.push('üîí CORS Policy Notes:');
                    results.push('   ‚Ä¢ Power Platform APIs require proper CORS configuration');
                    results.push('   ‚Ä¢ Browser-based apps may need server-side proxy for API calls');
                    results.push('   ‚Ä¢ Consider using MSAL.js for proper authentication flow');

                    return { message: results.join('\n') };
                    
                } catch (error) {
                    const details = `üìã Error: ${error.message}\n\nüí° This may indicate broader network connectivity issues.`;
                    
                    const err = new Error('Network connectivity test failed');
                    err.details = details;
                    throw err;
                }
            }

            async authenticate() {
                const { clientId, tenantId } = this.config;
                
                // Using Microsoft Authentication Library (MSAL) approach
                // In a real implementation, you would use MSAL.js library
                const authUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/authorize`;
                const redirectUri = encodeURIComponent(window.location.origin);
                const scope = encodeURIComponent('https://service.powerapps.com//.default');
                
                // For this demo, we'll simulate the authentication process
                // In production, implement proper OAuth 2.0 flow with MSAL.js
                this.showAlert('Authentication would redirect to Microsoft login...', 'warning');
                
                // Simulate token for demonstration
                await this.delay(1000);
                this.accessToken = 'simulated-access-token';
            }

            async fetchFlows() {
                if (!this.accessToken) {
                    throw new Error('No valid access token available');
                }

                const { environmentUrl } = this.config;
                
                try {
                    this.showLoading();
                    
                    // Construct the API endpoint for Power Automate flows
                    const apiEndpoint = `${environmentUrl}/api/data/v9.0/workflows`;
                    const queryParams = new URLSearchParams({
                        '$select': 'workflowid,name,statecode,statuscode,createdon,modifiedon,category',
                        '$filter': "category eq 5", // Category 5 = Modern Flow
                        '$orderby': 'modifiedon desc',
                        '$top': '100'
                    });

                    // In a real implementation, make the actual API call
                    // const response = await this.makeApiCall(`${apiEndpoint}?${queryParams}`);
                    
                    // For demonstration, simulate API response
                    await this.delay(1500);
                    const simulatedFlows = this.generateRealisticFlowData();
                    
                    this.flows = simulatedFlows;
                    this.filteredFlows = [...this.flows];
                    this.updateStats();
                    this.renderFlows();
                    this.updateLastUpdated();
                    
                    // Fetch run history for each flow
                    await this.fetchFlowRunHistory();
                    
                } catch (error) {
                    throw new Error(`Failed to fetch flows: ${error.message}`);
                }
            }

            async fetchFlowRunHistory() {
                // Fetch recent run history for each flow to determine health status
                const promises = this.flows.slice(0, 10).map(async (flow) => {
                    try {
                        // In production: GET /api/data/v9.0/workflowlogs
                        await this.delay(200); // Simulate API call
                        
                        // Simulate run history data
                        const runHistory = this.generateFlowRunHistory(flow.workflowid);
                        flow.runHistory = runHistory;
                        flow.lastRunStatus = runHistory[0]?.status || 'Unknown';
                        flow.lastRunTime = runHistory[0]?.completedOn || flow.modifiedon;
                        flow.failureRate = this.calculateFailureRate(runHistory);
                        
                    } catch (error) {
                        console.warn(`Failed to fetch run history for ${flow.name}:`, error);
                        flow.lastRunStatus = 'Unknown';
                        flow.failureRate = 0;
                    }
                });

                await Promise.all(promises);
                this.updateStats();
                this.renderFlows();
            }

            generateRealisticFlowData() {
                const flowTemplates = [
                    { name: 'Daily Sales Report Automation', category: 'Business Process' },
                    { name: 'Customer Onboarding Workflow', category: 'HR & Onboarding' },
                    { name: 'Invoice Processing Pipeline', category: 'Finance & Accounting' },
                    { name: 'Email Marketing Campaign Trigger', category: 'Marketing' },
                    { name: 'IT Ticket Assignment Handler', category: 'IT Operations' },
                    { name: 'Contract Approval Workflow', category: 'Legal & Compliance' },
                    { name: 'Inventory Stock Level Alerts', category: 'Supply Chain' },
                    { name: 'Employee Leave Request Handler', category: 'HR & Onboarding' },
                    { name: 'Social Media Content Scheduler', category: 'Marketing' },
                    { name: 'Data Backup Validation Process', category: 'IT Operations' }
                ];

                return flowTemplates.map((template, index) => ({
                    workflowid: `flow-${String(index + 1).padStart(3, '0')}`,
                    name: template.name,
                    category: template.category,
                    statecode: Math.random() > 0.1 ? 1 : 0, // 90% enabled
                    statuscode: Math.random() > 0.05 ? 1 : 2, // 95% active
                    createdon: new Date(Date.now() - Math.random() * 90 * 24 * 60 * 60 * 1000).toISOString(),
                    modifiedon: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(),
                    runHistory: [],
                    lastRunStatus: 'Unknown',
                    lastRunTime: null,
                    failureRate: 0
                }));
            }

            generateFlowRunHistory(flowId) {
                const statuses = ['Succeeded', 'Failed', 'Running', 'Cancelled'];
                const history = [];
                const numRuns = Math.floor(Math.random() * 20) + 5;

                for (let i = 0; i < numRuns; i++) {
                    const startTime = new Date(Date.now() - (i * 2 * 60 * 60 * 1000));
                    const endTime = new Date(startTime.getTime() + Math.random() * 300000); // 0-5 minutes duration
                    
                    // Higher probability of success for realistic data
                    let status;
                    const rand = Math.random();
                    if (rand < 0.85) status = 'Succeeded';
                    else if (rand < 0.95) status = 'Failed';
                    else if (rand < 0.98) status = 'Cancelled';
                    else status = 'Running';

                    history.push({
                        runId: `${flowId}-run-${i + 1}`,
                        status,
                        startedOn: startTime.toISOString(),
                        completedOn: status === 'Running' ? null : endTime.toISOString(),
                        duration: status === 'Running' ? null : Math.floor((endTime - startTime) / 1000),
                        error: status === 'Failed' ? this.generateRandomError() : null
                    });
                }

                return history.sort((a, b) => new Date(b.startedOn) - new Date(a.startedOn));
            }

            generateRandomError() {
                const errors = [
                    'Connection timeout to SharePoint service',
                    'Microsoft Graph API rate limit exceeded',
                    'Invalid authentication token',
                    'Required field validation failed',
                    'External service temporarily unavailable',
                    'Insufficient permissions to access resource',
                    'Data conversion error in connector'
                ];
                return errors[Math.floor(Math.random() * errors.length)];
            }

            calculateFailureRate(runHistory) {
                if (!runHistory || runHistory.length === 0) return 0;
                const failedRuns = runHistory.filter(run => run.status === 'Failed').length;
                return Math.round((failedRuns / runHistory.length) * 100);
            }

            async makeApiCall(url, options = {}) {
                const defaultOptions = {
                    headers: {
                        'Authorization': `Bearer ${this.accessToken}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                };

                const response = await fetch(url, { ...defaultOptions, ...options });
                
                if (!response.ok) {
                    const error = await response.text();
                    throw new Error(`API call failed: ${response.status} ${error}`);
                }

                return response.json();
            }

            setConnectedState(connected) {
                this.isConnected = connected;
                const connectBtn = document.getElementById('connectBtn');
                const refreshBtn = document.getElementById('refreshBtn');
                const exportBtn = document.getElementById('exportBtn');
                const searchBox = document.getElementById('searchBox');
                const statusIndicator = document.getElementById('statusIndicator');
                const connectionStatus = document.getElementById('connectionStatus');

                if (connected) {
                    connectBtn.textContent = '‚úÖ Connected';
                    connectBtn.className = 'btn btn-success';
                    connectBtn.disabled = false;
                    refreshBtn.disabled = false;
                    exportBtn.disabled = false;
                    searchBox.disabled = false;
                    statusIndicator.classList.add('connected');
                    connectionStatus.textContent = 'Connected';
                } else {
                    connectBtn.textContent = 'üîå Connect to Power Platform';
                    connectBtn.className = 'btn btn-primary';
                    connectBtn.disabled = false;
                    refreshBtn.disabled = true;
                    exportBtn.disabled = true;
                    searchBox.disabled = true;
                    statusIndicator.classList.remove('connected');
                    connectionStatus.textContent = 'Disconnected';
                    
                    if (this.refreshTimer) {
                        clearInterval(this.refreshTimer);
                        this.refreshTimer = null;
                    }
                }
            }

            async refreshData() {
                if (!this.isConnected) {
                    this.showAlert('Please connect to Power Platform first.', 'warning');
                    return;
                }

                try {
                    await this.fetchFlows();
                    this.showAlert('Data refreshed successfully!', 'success');
                } catch (error) {
                    this.showAlert(`Refresh failed: ${error.message}`, 'error');
                    console.error('Refresh error:', error);
                }
            }

            startAutoRefresh() {
                if (this.refreshTimer) {
                    clearInterval(this.refreshTimer);
                }

                const interval = this.config.refreshInterval * 1000;
                this.refreshTimer = setInterval(() => {
                    this.refreshData();
                }, interval);
            }

            updateStats() {
                const stats = this.flows.reduce((acc, flow) => {
                    acc.total++;
                    
                    if (flow.statecode === 1) acc.enabled++;
                    else acc.suspended++;
                    
                    if (flow.runHistory) {
                        const recentFails = flow.runHistory
                            .slice(0, 5) // Last 5 runs
                            .filter(run => run.status === 'Failed').length;
                        if (recentFails > 0) acc.recentFailures++;
                    }
                    
                    return acc;
                }, { enabled: 0, suspended: 0, recentFailures: 0, total: 0 });

                document.getElementById('enabledCount').textContent = stats.enabled;
                document.getElementById('suspendedCount').textContent = stats.suspended;
                document.getElementById('failedRunsCount').textContent = stats.recentFailures;
                document.getElementById('totalFlows').textContent = stats.total;
            }

            renderFlows() {
                const flowsList = document.getElementById('flowsList');
                
                if (this.filteredFlows.length === 0) {
                    flowsList.innerHTML = '<div class="loading"><p>No flows found.</p></div>';
                    return;
                }

                flowsList.innerHTML = this.filteredFlows.map(flow => {
                    const flowStatus = flow.statecode === 1 ? 'enabled' : 'suspended';
                    const lastRun = flow.lastRunTime ? new Date(flow.lastRunTime) : new Date(flow.modifiedon);
                    const runStatus = flow.lastRunStatus ? flow.lastRunStatus.toLowerCase() : 'unknown';
                    
                    return `
                        <div class="flow-item">
                            <div class="flow-header">
                                <div>
                                    <div class="flow-name">${flow.name}</div>
                                    <span class="flow-status status-${flowStatus}">${flowStatus.charAt(0).toUpperCase() + flowStatus.slice(1)}</span>
                                    ${flow.lastRunStatus ? `<span class="flow-status run-status-${runStatus}" style="margin-left: 8px;">Last Run: ${flow.lastRunStatus}</span>` : ''}
                                </div>
                            </div>
                            <div class="flow-details">
                                <div class="flow-metric">
                                    <span class="metric-label">Last Activity</span>
                                    <span class="metric-value">${this.formatTimeAgo(lastRun)}</span>
                                </div>
                                <div class="flow-metric">
                                    <span class="metric-label">Category</span>
                                    <span class="metric-value">${flow.category}</span>
                                </div>
                                <div class="flow-metric">
                                    <span class="metric-label">Total Runs</span>
                                    <span class="metric-value">${flow.runHistory ? flow.runHistory.length : '-'}</span>
                                </div>
                                <div class="flow-metric">
                                    <span class="metric-label">Failure Rate</span>
                                    <span class="metric-value">${flow.failureRate}%</span>
                                </div>
                                <div class="flow-metric">
                                    <span class="metric-label">Created</span>
                                    <span class="metric-value">${this.formatDate(new Date(flow.createdon))}</span>
                                </div>
                            </div>
                            ${flow.runHistory && flow.runHistory[0]?.error ? `<div class="error-message">Latest Error: ${flow.runHistory[0].error}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }

            filterFlows(searchTerm) {
                if (!searchTerm.trim()) {
                    this.filteredFlows = [...this.flows];
                } else {
                    this.filteredFlows = this.flows.filter(flow => 
                        flow.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                        flow.category.toLowerCase().includes(searchTerm.toLowerCase())
                    );
                }
                
                this.renderFlows();
            }

            formatTimeAgo(date) {
                const seconds = Math.floor((new Date() - date) / 1000);
                
                if (seconds < 60) return `${seconds}s ago`;
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            }

            formatDate(date) {
                return date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            }

            updateLastUpdated() {
                const now = new Date();
                document.getElementById('lastUpdated').textContent = 
                    `Last updated: ${now.toLocaleTimeString()}`;
            }

            showLoading() {
                const flowsList = document.getElementById('flowsList');
                flowsList.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading flow data...</p>
                    </div>
                `;
            }

            showAlert(message, type = 'info') {
                const alertBanner = document.getElementById('alertBanner');
                const alertMessage = document.getElementById('alertMessage');
                const alertIcon = document.getElementById('alertIcon');
                
                const icons = {
                    success: '‚úÖ',
                    error: '‚ùå',
                    warning: '‚ö†Ô∏è',
                    info: '‚ÑπÔ∏è'
                };
                
                alertIcon.textContent = icons[type] || icons.info;
                alertMessage.textContent = message;
                alertBanner.className = `alert-banner show ${type}`;
                
                setTimeout(() => {
                    alertBanner.classList.remove('show');
                }, 5000);
            }

            exportReport() {
                if (this.flows.length === 0) {
                    this.showAlert('No data available to export.', 'warning');
                    return;
                }

                const report = {
                    timestamp: new Date().toISOString(),
                    environment: this.config.environmentUrl,
                    summary: {
                        totalFlows: this.flows.length,
                        enabled: this.flows.filter(f => f.statecode === 1).length,
                        suspended: this.flows.filter(f => f.statecode === 0).length,
                        withRecentFailures: this.flows.filter(f => f.failureRate > 0).length,
                    },
                    flows: this.flows.map(flow => ({
                        id: flow.workflowid,
                        name: flow.name,
                        category: flow.category,
                        status: flow.statecode === 1 ? 'Enabled' : 'Suspended',
                        lastRunStatus: flow.lastRunStatus,
                        failureRate: flow.failureRate,
                        created: flow.createdon,
                        modified: flow.modifiedon,
                        runCount: flow.runHistory ? flow.runHistory.length : 0
                    }))
                };

                const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `power-automate-report-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showAlert('Report exported successfully!', 'success');
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize the monitor when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PowerAutomateMonitor();
        });

            async authenticate() {
                const { clientId, tenantId } = this.config;
                
                // Using Microsoft Authentication Library (MSAL) approach
                // In a real implementation, you would use MSAL.js library
                const authUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/authorize`;
                const redirectUri = encodeURIComponent(window.location.origin);
                const scope = encodeURIComponent('https://service.powerapps.com//.default');
                
                // For this demo, we'll simulate the authentication process
                // In production, implement proper OAuth 2.0 flow with MSAL.js
                this.showAlert('Authentication would redirect to Microsoft login...', 'warning');
                
                // Simulate token for demonstration
                await this.delay(1000);
                this.accessToken = 'simulated-access-token';
            }

            async fetchFlows() {
                if (!this.accessToken) {
                    throw new Error('No valid access token available');
                }

                const { environmentUrl } = this.config;
                
                try {
                    this.showLoading();
                    
                    // Construct the API endpoint for Power Automate flows
                    const apiEndpoint = `${environmentUrl}/api/data/v9.0/workflows`;
                    const queryParams = new URLSearchParams({
                        '$select': 'workflowid,name,statecode,statuscode,createdon,modifiedon,category',
                        '$filter': "category eq 5", // Category 5 = Modern Flow
                        '$orderby': 'modifiedon desc',
                        '$top': '100'
                    });

                    // In a real implementation, make the actual API call
                    // const response = await this.makeApiCall(`${apiEndpoint}?${queryParams}`);
                    
                    // For demonstration, simulate API response
                    await this.delay(1500);
                    const simulatedFlows = this.generateRealisticFlowData();
                    
                    this.flows = simulatedFlows;
                    this.filteredFlows = [...this.flows];
                    this.updateStats();
                    this.renderFlows();
                    this.updateLastUpdated();
                    
                    // Fetch run history for each flow
                    await this.fetchFlowRunHistory();
                    
                } catch (error) {
                    throw new Error(`Failed to fetch flows: ${error.message}`);
                }
            }

            async fetchFlowRunHistory() {
                // Fetch recent run history for each flow to determine health status
                const promises = this.flows.slice(0, 10).map(async (flow) => {
                    try {
                        // In production: GET /api/data/v9.0/workflowlogs
                        await this.delay(200); // Simulate API call
                        
                        // Simulate run history data
                        const runHistory = this.generateFlowRunHistory(flow.workflowid);
                        flow.runHistory = runHistory;
                        flow.lastRunStatus = runHistory[0]?.status || 'Unknown';
                        flow.lastRunTime = runHistory[0]?.completedOn || flow.modifiedon;
                        flow.failureRate = this.calculateFailureRate(runHistory);
                        
                    } catch (error) {
                        console.warn(`Failed to fetch run history for ${flow.name}:`, error);
                        flow.lastRunStatus = 'Unknown';
                        flow.failureRate = 0;
                    }
                });

                await Promise.all(promises);
                this.updateStats();
                this.renderFlows();
            }

            generateRealisticFlowData() {
                const flowTemplates = [
                    { name: 'Daily Sales Report Automation', category: 'Business Process' },
                    { name: 'Customer Onboarding Workflow', category: 'HR & Onboarding' },
                    { name: 'Invoice Processing Pipeline', category: 'Finance & Accounting' },
                    { name: 'Email Marketing Campaign Trigger', category: 'Marketing' },
                    { name: 'IT Ticket Assignment Handler', category: 'IT Operations' },
                    { name: 'Contract Approval Workflow', category: 'Legal & Compliance' },
                    { name: 'Inventory Stock Level Alerts', category: 'Supply Chain' },
                    { name: 'Employee Leave Request Handler', category: 'HR & Onboarding' },
                    { name: 'Social Media Content Scheduler', category: 'Marketing' },
                    { name: 'Data Backup Validation Process', category: 'IT Operations' }
                ];

                return flowTemplates.map((template, index) => ({
                    workflowid: `flow-${String(index + 1).padStart(3, '0')}`,
                    name: template.name,
                    category: template.category,
                    statecode: Math.random() > 0.1 ? 1 : 0, // 90% enabled
                    statuscode: Math.random() > 0.05 ? 1 : 2, // 95% active
                    createdon: new Date(Date.now() - Math.random() * 90 * 24 * 60 * 60 * 1000).toISOString(),
                    modifiedon: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(),
                    runHistory: [],
                    lastRunStatus: 'Unknown',
                    lastRunTime: null,
                    failureRate: 0
                }));
            }

            generateFlowRunHistory(flowId) {
                const statuses = ['Succeeded', 'Failed', 'Running', 'Cancelled'];
                const history = [];
                const numRuns = Math.floor(Math.random() * 20) + 5;

                for (let i = 0; i < numRuns; i++) {
                    const startTime = new Date(Date.now() - (i * 2 * 60 * 60 * 1000));
                    const endTime = new Date(startTime.getTime() + Math.random() * 300000); // 0-5 minutes duration
                    
                    // Higher probability of success for realistic data
                    let status;
                    const rand = Math.random();
                    if (rand < 0.85) status = 'Succeeded';
                    else if (rand < 0.95) status = 'Failed';
                    else if (rand < 0.98) status = 'Cancelled';
                    else status = 'Running';

                    history.push({
                        runId: `${flowId}-run-${i + 1}`,
                        status,
                        startedOn: startTime.toISOString(),
                        completedOn: status === 'Running' ? null : endTime.toISOString(),
                        duration: status === 'Running' ? null : Math.floor((endTime - startTime) / 1000),
                        error: status === 'Failed' ? this.generateRandomError() : null
                    });
                }

                return history.sort((a, b) => new Date(b.startedOn) - new Date(a.startedOn));
            }

            generateRandomError() {
                const errors = [
                    'Connection timeout to SharePoint service',
                    'Microsoft Graph API rate limit exceeded',
                    'Invalid authentication token',
                    'Required field validation failed',
                    'External service temporarily unavailable',
                    'Insufficient permissions to access resource',
                    'Data conversion error in connector'
                ];
                return errors[Math.floor(Math.random() * errors.length)];
            }

            calculateFailureRate(runHistory) {
                if (!runHistory || runHistory.length === 0) return 0;
                const failedRuns = runHistory.filter(run => run.status === 'Failed').length;
                return Math.round((failedRuns / runHistory.length) * 100);
            }

            async makeApiCall(url, options = {}) {
                const defaultOptions = {
                    headers: {
                        'Authorization': `Bearer ${this.accessToken}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                };

                const response = await fetch(url, { ...defaultOptions, ...options });
                
                if (!response.ok) {
                    const error = await response.text();
                    throw new Error(`API call failed: ${response.status} ${error}`);
                }

                return response.json();
            }

            setConnectedState(connected) {
                this.isConnected = connected;
                const connectBtn = document.getElementById('connectBtn');
                const refreshBtn = document.getElementById('refreshBtn');
                const exportBtn = document.getElementById('exportBtn');
                const searchBox = document.getElementById('searchBox');
                const statusIndicator = document.getElementById('statusIndicator');
                const connectionStatus = document.getElementById('connectionStatus');

                if (connected) {
                    connectBtn.textContent = '‚úÖ Connected';
                    connectBtn.className = 'btn btn-success';
                    connectBtn.disabled = false;
                    refreshBtn.disabled = false;
                    exportBtn.disabled = false;
                    searchBox.disabled = false;
                    statusIndicator.classList.add('connected');
                    connectionStatus.textContent = 'Connected';
                } else {
                    connectBtn.textContent = 'üîå Connect to Power Platform';
                    connectBtn.className = 'btn btn-primary';
                    connectBtn.disabled = false;
                    refreshBtn.disabled = true;
                    exportBtn.disabled = true;
                    searchBox.disabled = true;
                    statusIndicator.classList.remove('connected');
                    connectionStatus.textContent = 'Disconnected';
                    
                    if (this.refreshTimer) {
                        clearInterval(this.refreshTimer);
                        this.refreshTimer = null;
                    }
                }
            }

            async refreshData() {
                if (!this.isConnected) {
                    this.showAlert('Please connect to Power Platform first.', 'warning');
                    return;
                }

                try {
                    await this.fetchFlows();
                    this.showAlert('Data refreshed successfully!', 'success');
                } catch (error) {
                    this.showAlert(`Refresh failed: ${error.message}`, 'error');
                    console.error('Refresh error:', error);
                }
            }

            startAutoRefresh() {
                if (this.refreshTimer) {
                    clearInterval(this.refreshTimer);
                }

                const interval = this.config.refreshInterval * 1000;
                this.refreshTimer = setInterval(() => {
                    this.refreshData();
                }, interval);
            }

            updateStats() {
                const stats = this.flows.reduce((acc, flow) => {
                    acc.total++;
                    
                    if (flow.statecode === 1) acc.enabled++;
                    else acc.suspended++;
                    
                    if (flow.runHistory) {
                        const recentFails = flow.runHistory
                            .slice(